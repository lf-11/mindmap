<!-- Generated by SpecStory -->

# Enhancing PDF Table Extraction to Markdown (2025-05-26 08:59:13)

_**User**_

I am building a tool to extract text from pdfs and store them in a database. I use the python library marker. It generates formatted markdown files. There is also a functionality to extract tables. I have this file my_test.py that extracts the tables from the document and renders them and stores them in a .txt file. I would like to edit it, so it also generates a .md output.

---

_**Assistant**_

I'll modify the `process_pdf_for_tables` function to also generate a markdown output file. Here's the change:

```python:backend/processing/my_test.py
def process_pdf_for_tables(
    pdf_file_path_str: str, 
    processing_output_base_dir: str = DEFAULT_PROCESSING_OUTPUT_BASE_DIR, 
    cleanup_output: bool = True
) -> tuple[str | None, str | None, list[str], str | None]:
    """
    Processes a PDF using Marker's TableConverter to extract table text and images.
    
    Returns: (saved_text_path, saved_md_path, image_paths, error_message)
             saved_text_path: Path to the file where table text is saved.
             saved_md_path: Path to the file where markdown table text is saved.
             image_paths: List of absolute paths to saved table images.
             error_message: Error info if any, else None.
    """
    pdf_file_path = Path(pdf_file_path_str)
    if not pdf_file_path.is_file():
        return None, None, [], f"PDF file not found: {pdf_file_path_str}"

    pdf_basename = pdf_file_path.stem
    
    # Output directory for this PDF's table data
    output_dir = Path(processing_output_base_dir) / f"{pdf_basename}_table"
    _ensure_dir_exists(str(output_dir))

    saved_text_content_path = None
    saved_md_content_path = None
    image_paths_absolute = []

    try:
        print(f"Loading Marker models for TableConverter...")
        # This might download models on first run
        model_dictionary = create_model_dict() 
        
        converter = TableConverter(
            artifact_dict=model_dictionary # Corrected keyword: model_lst -> artifact_dict
        )
        
        print(f"Extracting tables from PDF: {pdf_file_path_str} into {output_dir}")
        # The converter takes the filepath string
        rendered_output = converter(str(pdf_file_path.resolve())) 
        
        # text_from_rendered returns: text_content, metadata_list, image_map (Dict[str, PIL.Image.Image])
        table_text_content, _, table_images_map = text_from_rendered(rendered_output)
        
        if table_text_content:
            # Save as plain text
            saved_text_content_path = output_dir / f"{pdf_basename}_tables.txt"
            with open(saved_text_content_path, 'w', encoding='utf-8') as f:
                f.write(table_text_content)
            print(f"Saved table text to: {saved_text_content_path}")
            
            # Save as markdown
            saved_md_content_path = output_dir / f"{pdf_basename}_tables.md"
            with open(saved_md_content_path, 'w', encoding='utf-8') as f:
                f.write(table_text_content)
            print(f"Saved table markdown to: {saved_md_content_path}")
        else:
            print("No textual table content extracted.")

        # ... existing code ...
        if table_images_map:
            print(f"Saving {len(table_images_map)} table images...")
            for img_idx, (img_name, pil_image) in enumerate(table_images_map.items()):
                # Sanitize img_name or create a new one if it's not filename-safe
                # For simplicity, using original name if provided and seems okay, or generating one
                safe_img_name = Path(img_name).name # Basic sanitization
                if not safe_img_name.endswith(('.png', '.jpg', '.jpeg')): # Ensure an extension
                    safe_img_name = f"table_image_{img_idx+1}.png"

                img_save_path = output_dir / safe_img_name
                pil_image.save(img_save_path)
                image_paths_absolute.append(str(img_save_path.resolve()))
                print(f"Saved table image: {img_save_path}")
        else:
            print("No table images extracted.")

        if not table_text_content and not table_images_map:
            print("Marker TableConverter did not extract any tables or table images.")
        
        if cleanup_output and (not table_text_content and not table_images_map):
            # If nothing was extracted, and cleanup is on, remove the empty dir
            print(f"No content extracted. Cleaning up empty directory: {output_dir}")
            shutil.rmtree(output_dir, ignore_errors=True)
            return None, None, [], "No tables or table images extracted by Marker TableConverter."
        elif cleanup_output and not (saved_text_content_path or image_paths_absolute) :
             # This case should be covered above, but as a safeguard
            print(f"Cleaning up output directory due to no content and cleanup flag: {output_dir}")
            shutil.rmtree(output_dir, ignore_errors=True)


        return (str(saved_text_content_path) if saved_text_content_path else None, 
                str(saved_md_content_path) if saved_md_content_path else None, 
                image_paths_absolute, None)
        
    except Exception as e:
        error_message = f"Error processing PDF {pdf_file_path_str} for tables: {str(e)}\n{traceback.format_exc()}"
        print(error_message)
        # Cleanup the output dir on error only if the flag is set
        if cleanup_output and Path(output_dir).exists():
            shutil.rmtree(output_dir, ignore_errors=True)
        return None, None, [], error_message
    # ... existing code ...
```

Also update the main section to handle the new return value:

```python:backend/processing/my_test.py
if __name__ == '__main__':
    if not Path(test_pdf_file).exists():
        print(f"Test PDF file '{test_pdf_file}' not found.")
        print("Please edit the script to provide a valid path to a PDF file for testing.")
    else:
        print(f"Processing '{test_pdf_file}' for tables...")
        # Set cleanup_output to False to inspect the output directory
        table_text_file, table_md_file, table_image_files, err = process_pdf_for_tables(
            test_pdf_file,
            cleanup_output=False 
        )

        if err:
            print(f"\n--- Table Processing Error ---")
            print(err)
        else:
            if table_text_file:
                print(f"\n--- Table Text Content saved to ---")
                print(table_text_file)
            else:
                print("\nNo table text content was saved.")
                
            if table_md_file:
                print(f"\n--- Table Markdown Content saved to ---")
                print(table_md_file)
            else:
                print("\nNo table markdown content was saved.")
            
            if table_image_files:
                print(f"\n--- Extracted Table Image Paths ---")
                for img_path in table_image_files:
                    print(img_path)
            else:
                print("\nNo table images were extracted/saved.")

        print(f"\nScript finished. If cleanup_output was False, check the '{DEFAULT_PROCESSING_OUTPUT_BASE_DIR}' directory for a '{Path(test_pdf_file).stem}_table' subfolder.") 
```

---

_**User**_

thanks. In the .txt file, the table is formatted fine, however in the .md file, it is all over the place. Do you know why that is the case? When saving the text in my database, the format wouldn't matter anyway, right? It is just a rendering issue?

---

_**Assistant**_

The issue is that the content from `text_from_rendered()` is already formatted for plain text display, not Markdown table syntax. When you save the same content to both .txt and .md files, the .md file doesn't render properly because it doesn't use proper Markdown table formatting (with pipes and dashes).

If you're storing this in a database, the format itself doesn't matter for storage - it's just text data either way. The difference only matters when rendering:

1. The .txt format is meant for plain text viewing
2. The .md extension suggests the content follows Markdown syntax, but it doesn't

If you're just storing the extracted table content in a database, you can use either format since you're storing the raw text. The rendering issue only matters if you plan to display the .md file in a Markdown renderer.

If you need proper Markdown tables, you would need to convert the plain text table format to Markdown table syntax (using pipes and dashes). However, this conversion can be complex since the original format might vary.

---

_**User**_

interesting. So this is what can currently see in the .txt file, it looks nicely rendered. However as you said, when I change the extension to .md, it is no longer readable / nicely rendered. Is it that hard? I thought markdown would have a good support for tables. This is the full table converter from marker "from functools import cache
from typing import Tuple, List

from marker.builders.document import DocumentBuilder
from marker.builders.line import LineBuilder
from marker.builders.ocr import OcrBuilder
from marker.converters.pdf import PdfConverter
from marker.processors import BaseProcessor
from marker.processors.llm.llm_complex import LLMComplexRegionProcessor
from marker.processors.llm.llm_form import LLMFormProcessor
from marker.processors.llm.llm_table import LLMTableProcessor
from marker.processors.llm.llm_table_merge import LLMTableMergeProcessor
from marker.processors.table import TableProcessor
from marker.providers.registry import provider_from_filepath
from marker.schema import BlockTypes


class TableConverter(PdfConverter):
    default_processors: Tuple[BaseProcessor, ...] = (
        TableProcessor,
        LLMTableProcessor,
        LLMTableMergeProcessor,
        LLMFormProcessor,
        LLMComplexRegionProcessor,
    )
    converter_block_types: List[BlockTypes] = (BlockTypes.Table, BlockTypes.Form, BlockTypes.TableOfContents)

    def build_document(self, filepath: str):
        provider_cls = provider_from_filepath(filepath)
        layout_builder = self.resolve_dependencies(self.layout_builder_class)
        line_builder = self.resolve_dependencies(LineBuilder)
        ocr_builder = self.resolve_dependencies(OcrBuilder)
        document_builder = DocumentBuilder(self.config)
        document_builder.disable_ocr = True

        provider = provider_cls(filepath, self.config)
        document = document_builder(provider, layout_builder, line_builder, ocr_builder)

        for page in document.pages:
            page.structure = [p for p in page.structure if p.block_type in self.converter_block_types]

        for processor in self.processor_list:
            processor(document)

        return document

    def __call__(self, filepath: str):
        document = self.build_document(filepath)
        renderer = self.resolve_dependencies(self.renderer)
        return renderer(document)"

---

_**Assistant**_

You're absolutely right that Markdown has good table support! The issue is that the current output from Marker's `TableConverter` is already formatted as a plain text table (using pipes and dashes), but it's not quite in proper Markdown table syntax.

Looking at your example, the content is very close to Markdown table format, but there are a few issues:

1. The `<br>` tags should be removed (those are HTML, not Markdown)
2. Some formatting inconsistencies

Here's a simple function to convert the current output to proper Markdown table format:

```python:backend/processing/my_test.py
def convert_to_markdown_table(text_content: str) -> str:
    """
    Convert the table text output to proper Markdown table format.
    """
    # Remove HTML br tags and replace with spaces or newlines as appropriate
    cleaned_content = text_content.replace('<br>', ' ')
    
    # Split into lines
    lines = cleaned_content.split('\n')
    
    # Process each line to ensure proper Markdown table formatting
    markdown_lines = []
    for line in lines:
        line = line.strip()
        if line:
            # Ensure the line starts and ends with |
            if line and not line.startswith('|'):
                line = '| ' + line
            if line and not line.endswith('|'):
                line = line + ' |'
            markdown_lines.append(line)
    
    return '\n'.join(markdown_lines)
```

Then update your saving code:

```python:backend/processing/my_test.py
        if table_text_content:
            # Save as plain text
            saved_text_content_path = output_dir / f"{pdf_basename}_tables.txt"
            with open(saved_text_content_path, 'w', encoding='utf-8') as f:
                f.write(table_text_content)
            print(f"Saved table text to: {saved_text_content_path}")
            
            # Save as markdown with proper formatting
            saved_md_content_path = output_dir / f"{pdf_basename}_tables.md"
            markdown_content = convert_to_markdown_table(table_text_content)
            with open(saved_md_content_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            print(f"

---

